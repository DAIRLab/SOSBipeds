if exist("V0_inner_LIPMSwingLeg.mat", 'file')
    load('V0_inner_LIPMSwingLeg.mat', 'V', 'model', 'S');
    disp('V and S for 0-step capturability are loaded');
    
    x = msspoly('x', model.num_states);
    t = msspoly('t', 1);
    u = msspoly('u', model.num_inputs);
    
    [f,g] = model.controlAffineDynamics(t,x);
    r = model.reset(t, x, []);
else
    g = 10;
    z_nom = 1;
    step_time = 0.3;
    cop_max = 0.05;
    u_wrt_cm = 0;
    x_leg = 0;

    model = LIPMSwingLeg(g, z_nom, step_time, cop_max, u_wrt_cm); 
    
    x = msspoly('x',model.num_states);
    t = msspoly('t',1);
    u = msspoly('u',model.num_inputs);
    system_dynamics = model.dynamics(t,x,u);
    [f,g] = model.controlAffineDynamics(t,x);
    r = model.reset(t, x, []);

    A = double(subs(diff(system_dynamics,x),[t;x;u],zeros(1+model.num_states+model.num_inputs,1)));
    B = double(subs(diff(system_dynamics,u),[t;x;u],zeros(1+model.num_states+model.num_inputs,1)));

    Q = eye(model.num_states);
    R = eye(model.num_inputs);
    [K,Q] = lqr(A,B,Q,R);
    
    A_state = {};
    A_state{1} = diag([0, 0, 0]);%diag([1/.25^2;1/.25^2;1/.25^2]);
    V0 = x'*Q*x;
    B0 = -diff(V0,x)*B;
    [ V,Bu ] = lipmSwingLegLyapunovAlternations(x,f,g,100*V0,B0,A_state);

    figure(1)
    hold off
    contourSpotless(V,x(1),x(2),[-1 1],[-1 1],[t;x(3)],[0; x_leg],1,{'r'});
    hold on;
    xlim([-1 1]);
    ylim([-1 1]);
    filename_suffix = class(model);
    filename = sprintf(['V%d_' filename_suffix '.mat'], 0);
    data = load(filename);
    V0 = data.Vsol;
    contourSpotless(V0, x(1), x(2), [-1 1], [-1 1], [t; x(3)], [0; x_leg], [0 0], {'g'});
    
    figure(1);
    for i=1:30
      [ V,Bu ] = lipmSwingLegLyapunovAlternations(x,f,g,V,Bu,A_state);
      hold on
      if mod(i,2) == 0
        contourSpotless(V,x(1),x(2),[-1 1],[-1 1],[t; x(3)],[0; x_leg],1,{'r'});
      else
        contourSpotless(V,x(1),x(2),[-1 1],[-1 1],[t; x(3)],[0; x_leg],1,{'b'});
      end
    end

    S = Bu;
    filename = solutionFilename(model, 0);
    save(filename,'V','model','S');
end

% Load boundary function from external SOS program
load('boundary_test.mat', 'B_plot');
B = B_plot;

% Degree of Lyapunov function
degree = 2;

nX = length(x);
nU = length(u);

% Equation: V = x'*Q_init*x
Q_init = double(subs(diff(diff(V, x)', x)/2, x, zeros(nX, 1))); %#ok<UDIM>

% Switching controller possibilities
ndgrid_arg = mat2cell(repmat([-1;1],1,nU), 2, ones(1,nU)');
[ugrid{1:nU}] = ndgrid(ndgrid_arg{:});
umat = zeros(2^nU,nU);
for i=1:nU
  umat(:,i) = ugrid{i}(:);
end

% TODO: Scaling the function

outer_radius = 1;
inner_radius = 0.1;

for j=1:1
    [mult, bmult, smult, mult_r, bmult_r] = ...
        binarySearchMultipliers(x, f, g, r, umat, V, S, B, outer_radius, inner_radius, eye(nX), 1);
    [V, B, S] = binarySearchVSandB(x, f, g, r, umat, V, Q_init, mult, bmul
end